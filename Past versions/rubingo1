package rubingo

import (
	"bytes"
	"crypto"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/x509"
	"database/sql"
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"encoding/pem"
	"errors"
	"fmt"
	"image"
	_ "image/gif"
	_ "image/jpeg"
	_ "image/png"
	"io"
	"log"
	"math"
	"math/big"
	mathrand "math/rand"
	"mime"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode/utf16"

	"github.com/gorilla/websocket"
	_ "modernc.org/sqlite"
)

// ═══════════════════════════════════════════════════════════════════════════════
//  Constants
// ═══════════════════════════════════════════════════════════════════════════════

const (
	DefaultUserAgent  = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36"
	DefaultAPIVersion = "6"
	DefaultTimeout    = 20 * time.Second
	DefaultChunkSize  = 1048576
	DownloadChunk     = 131072
)

var aesIV = make([]byte, 16)

// ═══════════════════════════════════════════════════════════════════════════════
//  Errors
// ═══════════════════════════════════════════════════════════════════════════════

var (
	ErrNotRegistered = errors.New("NOT_REGISTERED")
	ErrNoConnection  = errors.New("client is not connected, call Connect() first")
	ErrNetworkError  = errors.New("network error")
	ErrStopHandler   = errors.New("stop handler")
	ErrCancelled     = errors.New("cancelled")
	ErrInvalidInput  = errors.New("invalid input")
	ErrFileNotFound  = errors.New("file not found")
)

type RequestError struct {
	Status    string
	StatusDet string
	Data      map[string]interface{}
}

func (e *RequestError) Error() string {
	return fmt.Sprintf("RequestError: status=%s status_det=%s", e.Status, e.StatusDet)
}

func isInvalidOrNotRegistered(err error) bool {
	if err == nil {
		return false
	}
	var reqErr *RequestError
	if errors.As(err, &reqErr) {
		det := strings.ToUpper(reqErr.StatusDet)
		return det == "NOT_REGISTERED" ||
			det == "INVALID_INPUT" ||
			det == "INVALID_AUTH"
	}
	if errors.Is(err, ErrNotRegistered) {
		return true
	}
	errMsg := strings.ToUpper(err.Error())
	return strings.Contains(errMsg, "NOT_REGISTERED") ||
		strings.Contains(errMsg, "INVALID_INPUT") ||
		strings.Contains(errMsg, "INVALID_AUTH")
}

// ═══════════════════════════════════════════════════════════════════════════════
//  Media Helpers (Thumbnail & Audio)
// ═══════════════════════════════════════════════════════════════════════════════

// ResultMedia holds thumbnail/media information
type ResultMedia struct {
	Seconds int
	Width   int
	Height  int
	Image   []byte
}

// ToBase64 converts image to base64 string
func (r *ResultMedia) ToBase64() string {
	if r.Image == nil || len(r.Image) == 0 {
		return ""
	}
	return base64.StdEncoding.EncodeToString(r.Image)
}

// HasImage checks if image data exists
func (r *ResultMedia) HasImage() bool {
	return r.Image != nil && len(r.Image) > 0
}

// MediaThumbnail handles thumbnail generation
type MediaThumbnail struct{}

// NewMediaThumbnail creates a new MediaThumbnail instance
func NewMediaThumbnail() *MediaThumbnail {
	return &MediaThumbnail{}
}

// FromImage extracts thumbnail from image bytes
func (m *MediaThumbnail) FromImage(imageBytes []byte) *ResultMedia {
	result := &ResultMedia{
		Width:  200,
		Height: 200,
	}

	reader := bytes.NewReader(imageBytes)
	img, _, err := image.DecodeConfig(reader)
	if err == nil {
		result.Width = img.Width
		result.Height = img.Height
	}

	// For thumbnail, we keep original bytes (in production, resize to smaller)
	if len(imageBytes) < 100*1024 { // If less than 100KB, use as thumbnail
		result.Image = imageBytes
	}

	return result
}

// FromVideo extracts thumbnail from video bytes
// Note: Full implementation requires ffmpeg or similar library
func (m *MediaThumbnail) FromVideo(videoBytes []byte) *ResultMedia {
	result := &ResultMedia{
		Seconds: 1,
		Width:   200,
		Height:  200,
	}

	// Try to extract duration from MP4 header
	if len(videoBytes) > 32 {
		// Simple MP4 duration extraction (basic implementation)
		result.Seconds = m.extractMP4Duration(videoBytes)
	}

	return result
}

// extractMP4Duration tries to extract duration from MP4 file
func (m *MediaThumbnail) extractMP4Duration(data []byte) int {
	// Basic MP4 parsing - in production use a proper library
	// This is a simplified version
	if len(data) < 100 {
		return 1
	}

	// Look for mvhd box which contains duration
	mvhdPattern := []byte("mvhd")
	idx := bytes.Index(data, mvhdPattern)
	if idx == -1 || idx+24 >= len(data) {
		return 1
	}

	// Duration is at offset 16 from mvhd (for version 0)
	// This is simplified and may not work for all MP4 files
	return 1
}

// AudioResult holds audio file information
type AudioResult struct {
	Performer string
	Duration  int // in seconds for Music, milliseconds for Voice
	Title     string
}

// Audio handles audio file information extraction
type Audio struct{}

// NewAudio creates a new Audio instance
func NewAudio() *Audio {
	return &Audio{}
}

// GetAudioInfo extracts audio information from bytes
// Note: Full implementation requires a library like id3 or taglib
func (a *Audio) GetAudioInfo(audioBytes []byte) *AudioResult {
	result := &AudioResult{
		Performer: "Unknown",
		Duration:  0,
		Title:     "",
	}

	if len(audioBytes) < 128 {
		return result
	}

	// Try to read ID3v1 tag (last 128 bytes of MP3)
	if string(audioBytes[len(audioBytes)-128:len(audioBytes)-125]) == "TAG" {
		tagData := audioBytes[len(audioBytes)-128:]
		result.Title = strings.TrimSpace(string(bytes.TrimRight(tagData[3:33], "\x00")))
		result.Performer = strings.TrimSpace(string(bytes.TrimRight(tagData[33:63], "\x00")))
	}

	// Try to read ID3v2 tag (beginning of file)
	if len(audioBytes) > 10 && string(audioBytes[0:3]) == "ID3" {
		// ID3v2 parsing is more complex
		// This is a simplified version
		result = a.parseID3v2(audioBytes)
	}

	// Estimate duration from file size (rough estimate for MP3 at 128kbps)
	// 128kbps = 16KB/s
	estimatedDuration := len(audioBytes) / 16000
	if estimatedDuration > 0 {
		result.Duration = estimatedDuration
	}

	return result
}

// parseID3v2 parses ID3v2 tags
func (a *Audio) parseID3v2(data []byte) *AudioResult {
	result := &AudioResult{
		Performer: "Unknown",
		Duration:  0,
	}

	if len(data) < 10 || string(data[0:3]) != "ID3" {
		return result
	}

	// Get tag size (syncsafe integer)
	size := int(data[6])<<21 | int(data[7])<<14 | int(data[8])<<7 | int(data[9])
	if size > len(data)-10 {
		size = len(data) - 10
	}

	// Parse frames (simplified)
	offset := 10
	for offset < size+10-10 {
		if offset+10 > len(data) {
			break
		}

		frameID := string(data[offset : offset+4])
		frameSize := int(binary.BigEndian.Uint32(data[offset+4 : offset+8]))

		if frameSize <= 0 || offset+10+frameSize > len(data) {
			break
		}

		frameData := data[offset+10 : offset+10+frameSize]

		switch frameID {
		case "TPE1", "TPE2": // Artist
			if len(frameData) > 1 {
				result.Performer = strings.TrimSpace(string(bytes.TrimRight(frameData[1:], "\x00")))
			}
		case "TIT2": // Title
			if len(frameData) > 1 {
				result.Title = strings.TrimSpace(string(bytes.TrimRight(frameData[1:], "\x00")))
			}
		}

		offset += 10 + frameSize
	}

	return result
}

// ═══════════════════════════════════════════════════════════════════════════════
//  HTML to Markdown Converter
// ═══════════════════════════════════════════════════════════════════════════════

// HTMLConverter converts HTML to Markdown
type HTMLConverter struct{}

// NewHTMLConverter creates a new HTML converter
func NewHTMLConverter() *HTMLConverter {
	return &HTMLConverter{}
}

// ToMarkdown converts HTML string to Markdown
func (h *HTMLConverter) ToMarkdown(html string) string {
	result := html

	// Basic HTML to Markdown conversions
	replacements := map[string]string{
		"<b>":       "**",
		"</b>":      "**",
		"<strong>":  "**",
		"</strong>": "**",
		"<i>":       "__",
		"</i>":      "__",
		"<em>":      "__",
		"</em>":     "__",
		"<u>":       "--",
		"</u>":      "--",
		"<s>":       "~~",
		"</s>":      "~~",
		"<strike>":  "~~",
		"</strike>": "~~",
		"<del>":     "~~",
		"</del>":    "~~",
		"<code>":    "`",
		"</code>":   "`",
		"<br>":      "\n",
		"<br/>":     "\n",
		"<br />":    "\n",
		"&lt;":      "<",
		"&gt;":      ">",
		"&amp;":     "&",
		"&quot;":    "\"",
		"&nbsp;":    " ",
	}

	for old, new := range replacements {
		result = strings.ReplaceAll(result, old, new)
	}

	// Handle <pre> tags
	preRE := regexp.MustCompile(`<pre(?:\s+[^>]*)?>([^<]*)</pre>`)
	result = preRE.ReplaceAllString(result, "```$1```")

	// Handle <a> tags
	linkRE := regexp.MustCompile(`<a\s+href=["']([^"']+)["'][^>]*>([^<]*)</a>`)
	result = linkRE.ReplaceAllString(result, "[$2]($1)")

	// Handle <spoiler> or custom spoiler tags
	spoilerRE := regexp.MustCompile(`<spoiler>([^<]*)</spoiler>`)
	result = spoilerRE.ReplaceAllString(result, "||$1||")

	// Remove any remaining HTML tags
	tagRE := regexp.MustCompile(`<[^>]+>`)
	result = tagRE.ReplaceAllString(result, "")

	return strings.TrimSpace(result)
}

// ═══════════════════════════════════════════════════════════════════════════════
//  Markdown Parser
// ═══════════════════════════════════════════════════════════════════════════════

var markdownRE = regexp.MustCompile(
	`(?m)(?:^(?:> ?[^\n]*\n?)+)` + "|" +
		"```([\\s\\S]*?)```" + "|" +
		`\*\*([^\n*]+?)\*\*` + "|" +
		"`([^\n`]+?)`" + "|" +
		`__([^\n_]+?)__` + "|" +
		`--([^\n-]+?)--` + "|" +
		`~~([^\n~]+?)~~` + "|" +
		`\|\|([^\n|]+?)\|\|` + "|" +
		`\[([^\]]+?)\]\((\S+)\)`,
)

type MetaDataPart struct {
	Type                  string                 `json:"type"`
	FromIndex             int                    `json:"from_index"`
	Length                int                    `json:"length"`
	Language              string                 `json:"language,omitempty"`
	LinkURL               string                 `json:"link_url,omitempty"`
	Link                  map[string]interface{} `json:"link,omitempty"`
	MentionTextObjectGUID string                 `json:"mention_text_object_guid,omitempty"`
	MentionTextUserID     string                 `json:"mention_text_user_id,omitempty"`
	MentionTextObjectType string                 `json:"mention_text_object_type,omitempty"`
}

type Metadata struct {
	MetaDataParts []MetaDataPart `json:"meta_data_parts"`
}

type MetadataResult struct {
	Text     string    `json:"text"`
	Metadata *Metadata `json:"metadata,omitempty"`
}

var mentionPrefixTypes = map[byte]string{
	'u': "User",
	'g': "Group",
	'c': "Channel",
	'b': "Bot",
}

func utf16Len(s string) int {
	count := 0
	for _, r := range s {
		if r > 0xFFFF {
			count += 2
		} else {
			count++
		}
	}
	return count
}

func buildUTF16PrefixLengths(text string) []int {
	runes := []rune(text)
	prefixLengths := make([]int, len(runes)+1)
	total := 0
	for i, r := range runes {
		if r > 0xFFFF {
			total += 2
		} else {
			total++
		}
		prefixLengths[i+1] = total
	}
	return prefixLengths
}

type MarkdownParser struct {
	htmlConverter *HTMLConverter
}

func NewMarkdownParser() *MarkdownParser {
	return &MarkdownParser{
		htmlConverter: NewHTMLConverter(),
	}
}

// ToMarkdown converts HTML to Markdown
func (mp *MarkdownParser) ToMarkdown(html string) string {
	return mp.htmlConverter.ToMarkdown(html)
}

func (mp *MarkdownParser) ToMetadata(text string) MetadataResult {
	metaDataParts := []MetaDataPart{}
	currentText := text
	offset := 0
	charOffset := 0
	utf16Prefix := buildUTF16PrefixLengths(text)

	matches := markdownRE.FindAllStringIndex(text, -1)
	submatches := markdownRE.FindAllStringSubmatch(text, -1)
	submatchIndices := markdownRE.FindAllStringSubmatchIndex(text, -1)

	for mi, match := range matches {
		start := match[0]
		end := match[1]
		group := text[start:end]
		sub := submatches[mi]
		subIdx := submatchIndices[mi]

		runeStart := len([]rune(text[:start]))
		runeEnd := len([]rune(text[:end]))

		adjustedStart := utf16Prefix[runeStart] - offset
		adjustedCharStart := runeStart - charOffset

		var mdType string
		var groupIdx int
		var content string
		var contentLength int
		var charContentLength int
		found := false

		if strings.HasPrefix(group, "> ") || (strings.HasPrefix(group, ">") && !strings.HasPrefix(group, ">>")) {
			mdType = "Quote"
			lines := strings.Split(group, "\n")
			var contentLines []string
			for _, line := range lines {
				if strings.HasPrefix(line, "> ") {
					contentLines = append(contentLines, line[2:])
				} else if strings.HasPrefix(line, ">") {
					contentLines = append(contentLines, line[1:])
				} else {
					contentLines = append(contentLines, line)
				}
			}
			content = strings.Join(contentLines, "\n")
			contentLength = utf16Len(content)
			charContentLength = len([]rune(content))

			inner := mp.ToMetadata(content)
			content = inner.Text
			contentLength = utf16Len(content)
			charContentLength = len([]rune(content))

			if inner.Metadata != nil {
				for _, part := range inner.Metadata.MetaDataParts {
					part.FromIndex += adjustedStart
					metaDataParts = append(metaDataParts, part)
				}
			}
			found = true
		} else if strings.HasPrefix(group, "```") {
			mdType = "Pre"
			groupIdx = 1
			found = true
		} else if strings.HasPrefix(group, "**") {
			mdType = "Bold"
			groupIdx = 2
			found = true
		} else if strings.HasPrefix(group, "`") {
			mdType = "Mono"
			groupIdx = 3
			found = true
		} else if strings.HasPrefix(group, "__") {
			mdType = "Italic"
			groupIdx = 4
			found = true
		} else if strings.HasPrefix(group, "--") {
			mdType = "Underline"
			groupIdx = 5
			found = true
		} else if strings.HasPrefix(group, "~~") {
			mdType = "Strike"
			groupIdx = 6
			found = true
		} else if strings.HasPrefix(group, "||") {
			mdType = "Spoiler"
			groupIdx = 7
			found = true
		} else if strings.HasPrefix(group, "[") {
			mdType = "Link"
			groupIdx = 8
			found = true
		}

		if !found {
			continue
		}

		if mdType != "Quote" {
			if groupIdx > 0 && groupIdx < len(sub) && sub[groupIdx] != "" {
				content = sub[groupIdx]
				gStart := subIdx[groupIdx*2]
				gEnd := subIdx[groupIdx*2+1]
				if gStart >= 0 && gEnd >= 0 {
					runeGStart := len([]rune(text[:gStart]))
					runeGEnd := len([]rune(text[:gEnd]))
					contentLength = utf16Prefix[runeGEnd] - utf16Prefix[runeGStart]
					charContentLength = runeGEnd - runeGStart
				}

				if mdType != "Pre" && mdType != "Link" {
					inner := mp.ToMetadata(content)
					content = inner.Text
					contentLength = utf16Len(content)
					charContentLength = len([]rune(content))
					if inner.Metadata != nil {
						for _, part := range inner.Metadata.MetaDataParts {
							part.FromIndex += adjustedStart
							metaDataParts = append(metaDataParts, part)
						}
					}
				}
			} else {
				content = ""
				contentLength = 0
				charContentLength = 0
			}
		}

		part := MetaDataPart{
			Type:      mdType,
			FromIndex: adjustedStart,
			Length:    contentLength,
		}

		if mdType == "Pre" {
			lines := strings.SplitN(content, "\n", 2)
			part.Language = strings.TrimSpace(lines[0])
		} else if mdType == "Link" {
			linkURL := ""
			if len(sub) > 9 {
				linkURL = sub[9]
			}
			if len(linkURL) > 0 {
				mentionType, ok := mentionPrefixTypes[linkURL[0]]
				if !ok {
					part.LinkURL = linkURL
					part.Link = map[string]interface{}{
						"type":           "hyperlink",
						"hyperlink_data": map[string]string{"url": linkURL},
					}
				} else {
					part.Type = "MentionText"
					part.MentionTextObjectGUID = linkURL
					part.MentionTextUserID = linkURL
					part.MentionTextObjectType = mentionType
				}
			}
		}

		metaDataParts = append(metaDataParts, part)

		markupLength := utf16Prefix[runeEnd] - utf16Prefix[runeStart]
		charMarkupLength := runeEnd - runeStart

		runeCurrentText := []rune(currentText)
		newText := make([]rune, 0, len(runeCurrentText))
		newText = append(newText, runeCurrentText[:adjustedCharStart]...)
		newText = append(newText, []rune(content)...)
		restStart := runeEnd - charOffset
		if restStart < len(runeCurrentText) {
			newText = append(newText, runeCurrentText[restStart:]...)
		}
		currentText = string(newText)

		offset += markupLength - contentLength
		charOffset += charMarkupLength - charContentLength
	}

	result := MetadataResult{
		Text: strings.TrimSpace(currentText),
	}
	if len(metaDataParts) > 0 {
		result.Metadata = &Metadata{MetaDataParts: metaDataParts}
	}
	return result
}

// ═══════════════════════════════════════════════════════════════════════════════
//  Crypto
// ═══════════════════════════════════════════════════════════════════════════════

type CryptoHelper struct{}

func NewCrypto() *CryptoHelper {
	return &CryptoHelper{}
}

func (c *CryptoHelper) DecodeAuth(auth string) string {
	lowerTo := make([]byte, 26)
	for i := 0; i < 26; i++ {
		lowerTo[i] = byte(((32 - i) % 26) + 97)
	}

	upperTo := make([]byte, 26)
	for i := 0; i < 26; i++ {
		upperTo[i] = byte(((29 - i) % 26) + 65)
	}

	digitTo := make([]byte, 10)
	for i := 0; i < 10; i++ {
		digitTo[i] = byte(((13 - i) % 10) + 48)
	}

	var result strings.Builder
	for _, ch := range auth {
		if ch >= 'a' && ch <= 'z' {
			result.WriteByte(lowerTo[ch-'a'])
		} else if ch >= 'A' && ch <= 'Z' {
			result.WriteByte(upperTo[ch-'A'])
		} else if ch >= '0' && ch <= '9' {
			result.WriteByte(digitTo[ch-'0'])
		} else {
			result.WriteRune(ch)
		}
	}
	return result.String()
}

func (c *CryptoHelper) Passphrase(auth string) string {
	if len(auth) != 32 {
		panic("auth length should be 32 digits")
	}
	chunks := make([]string, 4)
	for i := 0; i < 4; i++ {
		chunks[i] = auth[i*8 : (i+1)*8]
	}
	combined := chunks[2] + chunks[0] + chunks[3] + chunks[1]
	var result strings.Builder
	for _, ch := range combined {
		result.WriteByte(byte(((int(ch) - 97 + 9) % 26) + 97))
	}
	return result.String()
}

func (c *CryptoHelper) Secret(length int) string {
	const letters = "abcdefghijklmnopqrstuvwxyz"
	b := make([]byte, length)
	for i := range b {
		n, _ := rand.Int(rand.Reader, big.NewInt(int64(len(letters))))
		b[i] = letters[n.Int64()]
	}
	return string(b)
}

func pkcs7Pad(data []byte, blockSize int) []byte {
	padding := blockSize - len(data)%blockSize
	padText := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(data, padText...)
}

func pkcs7Unpad(data []byte) ([]byte, error) {
	if len(data) == 0 {
		return nil, errors.New("empty data")
	}
	padding := int(data[len(data)-1])
	if padding > len(data) || padding == 0 {
		return nil, errors.New("invalid padding")
	}
	for i := len(data) - padding; i < len(data); i++ {
		if data[i] != byte(padding) {
			return nil, errors.New("invalid padding")
		}
	}
	return data[:len(data)-padding], nil
}

func (c *CryptoHelper) Encrypt(data interface{}, key string) (string, error) {
	var plaintext []byte
	switch v := data.(type) {
	case string:
		plaintext = []byte(v)
	default:
		j, err := json.Marshal(v)
		if err != nil {
			return "", err
		}
		plaintext = j
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return "", err
	}

	padded := pkcs7Pad(plaintext, aes.BlockSize)
	ciphertext := make([]byte, len(padded))
	mode := cipher.NewCBCEncrypter(block, aesIV)
	mode.CryptBlocks(ciphertext, padded)

	return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func (c *CryptoHelper) Decrypt(data string, key string) (map[string]interface{}, error) {
	decoded, err := base64.URLEncoding.DecodeString(data)
	if err != nil {
		decoded, err = base64.StdEncoding.DecodeString(data)
		if err != nil {
			return nil, fmt.Errorf("base64 decode error: %w", err)
		}
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return nil, err
	}

	if len(decoded)%aes.BlockSize != 0 {
		return nil, errors.New("ciphertext is not a multiple of the block size")
	}

	mode := cipher.NewCBCDecrypter(block, aesIV)
	mode.CryptBlocks(decoded, decoded)

	unpadded, err := pkcs7Unpad(decoded)
	if err != nil {
		return nil, err
	}

	var result map[string]interface{}
	if err := json.Unmarshal(unpadded, &result); err != nil {
		return nil, err
	}
	return result, nil
}

func (c *CryptoHelper) Sign(privateKey *rsa.PrivateKey, data string) (string, error) {
	hash := sha256.Sum256([]byte(data))
	signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(signature), nil
}

func (c *CryptoHelper) CreateKeys() (publicKeyEncoded string, privateKeyPEM string, err error) {
	key, err := rsa.GenerateKey(rand.Reader, 1024)
	if err != nil {
		return "", "", err
	}

	pubASN1, err := x509.MarshalPKIXPublicKey(&key.PublicKey)
	if err != nil {
		return "", "", err
	}
	pubPEM := pem.EncodeToMemory(&pem.Block{Type: "PUBLIC KEY", Bytes: pubASN1})
	pubEncoded := base64.StdEncoding.EncodeToString(pubPEM)
	publicKeyEncoded = c.DecodeAuth(pubEncoded)

	privPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509.MarshalPKCS1PrivateKey(key),
	})
	privateKeyPEM = string(privPEM)

	return publicKeyEncoded, privateKeyPEM, nil
}

func (c *CryptoHelper) DecryptRSAOAEP(privateKeyPEM string, data string) (string, error) {
	block, _ := pem.Decode([]byte(privateKeyPEM))
	if block == nil {
		return "", errors.New("failed to parse PEM block")
	}

	key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		return "", err
	}

	decoded, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return "", err
	}

	plaintext, err1 := rsa.DecryptPKCS1v15(rand.Reader, key, decoded)
	if err1 == nil {
		return string(plaintext), nil
	}

	plaintext, err2 := rsa.DecryptOAEP(sha1.New(), rand.Reader, key, decoded, nil)
	if err2 == nil {
		return string(plaintext), nil
	}

	plaintext, err3 := rsa.DecryptOAEP(sha256.New(), rand.Reader, key, decoded, nil)
	if err3 == nil {
		return string(plaintext), nil
	}

	return "", fmt.Errorf("all decryption methods failed: pkcs1v15=%v, oaep_sha1=%v, oaep_sha256=%v", err1, err2, err3)
}

func parsePrivateKey(privateKeyPEM string) (*rsa.PrivateKey, error) {
	if !strings.HasPrefix(privateKeyPEM, "-----BEGIN RSA PRIVATE KEY-----") {
		privateKeyPEM = "-----BEGIN RSA PRIVATE KEY-----\n" + privateKeyPEM
	}
	if !strings.HasSuffix(strings.TrimSpace(privateKeyPEM), "-----END RSA PRIVATE KEY-----") {
		privateKeyPEM = strings.TrimSpace(privateKeyPEM) + "\n-----END RSA PRIVATE KEY-----"
	}

	block, _ := pem.Decode([]byte(privateKeyPEM))
	if block == nil {
		return nil, errors.New("failed to parse PEM block")
	}
	return x509.ParsePKCS1PrivateKey(block.Bytes)
}

// ═══════════════════════════════════════════════════════════════════════════════
//  Update with Full Methods
// ═══════════════════════════════════════════════════════════════════════════════

type Update struct {
	Data   map[string]interface{}
	Client *RubClient
}

func NewUpdate(data map[string]interface{}) *Update {
	u := &Update{Data: data}
	if c, ok := data["client"]; ok {
		if client, ok := c.(*RubClient); ok {
			u.Client = client
		}
	}
	return u
}

func (u *Update) String() string {
	j, _ := json.MarshalIndent(u.Data, "", "  ")
	return string(j)
}

func (u *Update) Get(key string) interface{} {
	return u.FindKeys([]string{key}, u.Data)
}

func (u *Update) GetString(key string) string {
	v := u.Get(key)
	if v == nil {
		return ""
	}
	if s, ok := v.(string); ok {
		return s
	}
	return fmt.Sprintf("%v", v)
}

func (u *Update) GetFloat64(key string) float64 {
	v := u.Get(key)
	if v == nil {
		return 0
	}
	if f, ok := v.(float64); ok {
		return f
	}
	return 0
}

func (u *Update) GetInt(key string) int {
	v := u.Get(key)
	if v == nil {
		return 0
	}
	switch val := v.(type) {
	case float64:
		return int(val)
	case int:
		return val
	case int64:
		return int(val)
	case string:
		i, _ := strconv.Atoi(val)
		return i
	}
	return 0
}

func (u *Update) GetBool(key string) bool {
	v := u.Get(key)
	if v == nil {
		return false
	}
	if b, ok := v.(bool); ok {
		return b
	}
	return false
}

func (u *Update) GetMap(key string) map[string]interface{} {
	v := u.Get(key)
	if v == nil {
		return nil
	}
	if m, ok := v.(map[string]interface{}); ok {
		return m
	}
	return nil
}

func (u *Update) GetUpdate(key string) *Update {
	m := u.GetMap(key)
	if m == nil {
		return nil
	}
	return NewUpdate(m)
}

func (u *Update) GetSlice(key string) []interface{} {
	v := u.Get(key)
	if v == nil {
		return nil
	}
	if s, ok := v.([]interface{}); ok {
		return s
	}
	return nil
}

func (u *Update) FindKeys(keys []string, data interface{}) interface{} {
	if data == nil {
		data = u.Data
	}

	switch d := data.(type) {
	case map[string]interface{}:
		for _, key := range keys {
			if val, ok := d[key]; ok {
				return val
			}
		}
		for _, val := range d {
			result := u.FindKeys(keys, val)
			if result != nil {
				return result
			}
		}
	case []interface{}:
		for _, val := range d {
			result := u.FindKeys(keys, val)
			if result != nil {
				return result
			}
		}
	}
	return nil
}

// ─── Properties ─────────────────────────────────

func (u *Update) ObjectGUID() string {
	v := u.FindKeys([]string{"group_guid", "object_guid", "channel_guid"}, u.Data)
	if v == nil {
		return ""
	}
	return fmt.Sprintf("%v", v)
}

func (u *Update) MessageID() string {
	v := u.FindKeys([]string{"message_id", "pinned_message_id"}, u.Data)
	if v == nil {
		return ""
	}
	return fmt.Sprintf("%v", v)
}

func (u *Update) AuthorGUID() string {
	msg := u.GetMap("message")
	if msg == nil {
		return ""
	}
	if v, ok := msg["author_object_guid"]; ok {
		return fmt.Sprintf("%v", v)
	}
	return ""
}

func (u *Update) Text() string {
	msg := u.GetMap("message")
	if msg == nil {
		return ""
	}
	if v, ok := msg["text"]; ok {
		return fmt.Sprintf("%v", v)
	}
	return ""
}

func (u *Update) Type() string {
	v := u.FindKeys([]string{"type", "author_type"}, u.Data)
	if v == nil {
		return ""
	}
	return fmt.Sprintf("%v", v)
}

func (u *Update) ReplyMessageID() string {
	msg := u.GetMap("message")
	if msg == nil {
		return ""
	}
	if v, ok := msg["reply_to_message_id"]; ok {
		return fmt.Sprintf("%v", v)
	}
	return ""
}

func (u *Update) Title() string {
	return u.GetString("title")
}

func (u *Update) Command() string {
	return u.GetString("command")
}

func (u *Update) Status() string {
	return u.GetString("status")
}

func (u *Update) Action() bool {
	_, ok := u.Data["action"]
	return ok
}

// ─── Boolean Properties ─────────────────────────

func (u *Update) IsGroup() bool   { return u.Type() == "Group" }
func (u *Update) IsChannel() bool { return u.Type() == "Channel" }
func (u *Update) IsPrivate() bool { return u.Type() == "User" }

func (u *Update) IsMe() bool {
	if u.Client == nil {
		return false
	}
	return u.AuthorGUID() == u.Client.GUID
}

func (u *Update) IsEdited() bool {
	msg := u.GetMap("message")
	if msg == nil {
		return false
	}
	_, ok := msg["is_edited"]
	return ok
}

func (u *Update) IsForward() bool {
	msg := u.GetMap("message")
	if msg == nil {
		return false
	}
	_, ok := msg["forwarded_from"]
	return ok
}

func (u *Update) ForwardTypeFrom() string {
	msg := u.GetMap("message")
	if msg == nil {
		return ""
	}
	if ff, ok := msg["forwarded_from"].(map[string]interface{}); ok {
		if tf, ok := ff["type_from"].(string); ok {
			return tf
		}
	}
	return ""
}

func (u *Update) IsEvent() bool {
	msg := u.GetMap("message")
	if msg == nil {
		return false
	}
	if t, ok := msg["type"].(string); ok {
		return t == "Event"
	}
	return false
}

func (u *Update) EventData() *Update {
	if !u.IsEvent() {
		return nil
	}
	msg := u.GetMap("message")
	if msg == nil {
		return nil
	}
	if ed, ok := msg["event_data"].(map[string]interface{}); ok {
		return NewUpdate(ed)
	}
	return nil
}

func (u *Update) IsText() bool {
	msg := u.GetMap("message")
	if msg == nil {
		return false
	}
	if t, ok := msg["type"].(string); ok {
		return t == "Text"
	}
	return false
}

func (u *Update) IsFileInline() bool {
	msg := u.GetMap("message")
	if msg == nil {
		return false
	}
	if t, ok := msg["type"].(string); ok {
		return t == "FileInline" || t == "FileInlineCaption"
	}
	return false
}

// ─── File Properties ────────────────────────────

func (u *Update) FileInline() *Update {
	fi := u.GetMap("file_inline")
	if fi == nil {
		return nil
	}
	up := NewUpdate(fi)
	up.Client = u.Client
	return up
}

func (u *Update) FileType() string {
	fi := u.FileInline()
	if fi == nil {
		return ""
	}
	return fi.GetString("type")
}

func (u *Update) IsMusic() bool    { return u.FileType() == "Music" }
func (u *Update) IsFile() bool     { return u.FileType() == "File" }
func (u *Update) IsPhoto() bool    { return u.FileType() == "Image" }
func (u *Update) IsVideo() bool    { return u.FileType() == "Video" }
func (u *Update) IsVoice() bool    { return u.FileType() == "Voice" }
func (u *Update) IsGif() bool      { return u.FileType() == "Gif" }
func (u *Update) IsContact() bool  { return u.FileType() == "Contact" }
func (u *Update) IsLocation() bool { return u.FileType() == "Location" }
func (u *Update) IsPoll() bool     { return u.FileType() == "Poll" }

func (u *Update) Sticker() *Update {
	s := u.GetMap("sticker")
	if s == nil {
		return nil
	}
	return NewUpdate(s)
}

func (u *Update) IsSticker() bool {
	return u.Sticker() != nil
}

// ─── Helper Methods ─────────────────────────────

func (u *Update) GUIDType(objectGUID string) string {
	if objectGUID == "" {
		objectGUID = u.ObjectGUID()
	}
	if strings.HasPrefix(objectGUID, "c0") {
		return "Channel"
	} else if strings.HasPrefix(objectGUID, "g0") {
		return "Group"
	}
	return "User"
}

func (u *Update) ToDict() map[string]interface{} {
	return u.Data
}

// ─── Async-like Action Methods ──────────────────

// Reply sends a reply message
func (u *Update) Reply(text string, opts ...SendMessageOptions) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}

	options := SendMessageOptions{
		ObjectGUID:       u.ObjectGUID(),
		Text:             text,
		ReplyToMessageID: u.MessageID(),
	}

	if len(opts) > 0 {
		opt := opts[0]
		if opt.FileInline != nil {
			options.FileInline = opt.FileInline
		}
		if opt.Type != "" {
			options.Type = opt.Type
		}
		if opt.AutoDelete > 0 {
			options.AutoDelete = opt.AutoDelete
		}
		if opt.ParseMode != "" {
			options.ParseMode = opt.ParseMode
		}
	}

	return u.Client.SendMessage(options)
}

// ReplyPhoto sends a photo as reply
func (u *Update) ReplyPhoto(photo interface{}, caption string) (*Update, error) {
	return u.Client.SendMessage(SendMessageOptions{
		ObjectGUID:       u.ObjectGUID(),
		Text:             caption,
		ReplyToMessageID: u.MessageID(),
		FileInline:       photo,
		Type:             "Image",
	})
}

// ReplyVideo sends a video as reply
func (u *Update) ReplyVideo(video interface{}, caption string) (*Update, error) {
	return u.Client.SendMessage(SendMessageOptions{
		ObjectGUID:       u.ObjectGUID(),
		Text:             caption,
		ReplyToMessageID: u.MessageID(),
		FileInline:       video,
		Type:             "Video",
	})
}

// ReplyDocument sends a document as reply
func (u *Update) ReplyDocument(doc interface{}, caption string) (*Update, error) {
	return u.Client.SendMessage(SendMessageOptions{
		ObjectGUID:       u.ObjectGUID(),
		Text:             caption,
		ReplyToMessageID: u.MessageID(),
		FileInline:       doc,
		Type:             "File",
	})
}

// ReplyMusic sends music as reply
func (u *Update) ReplyMusic(music interface{}, caption string) (*Update, error) {
	return u.Client.SendMessage(SendMessageOptions{
		ObjectGUID:       u.ObjectGUID(),
		Text:             caption,
		ReplyToMessageID: u.MessageID(),
		FileInline:       music,
		Type:             "Music",
	})
}

// ReplyVoice sends voice as reply
func (u *Update) ReplyVoice(voice interface{}, caption string) (*Update, error) {
	return u.Client.SendMessage(SendMessageOptions{
		ObjectGUID:       u.ObjectGUID(),
		Text:             caption,
		ReplyToMessageID: u.MessageID(),
		FileInline:       voice,
		Type:             "Voice",
	})
}

// ReplyGif sends a gif as reply
func (u *Update) ReplyGif(gif interface{}, caption string) (*Update, error) {
	return u.Client.SendMessage(SendMessageOptions{
		ObjectGUID:       u.ObjectGUID(),
		Text:             caption,
		ReplyToMessageID: u.MessageID(),
		FileInline:       gif,
		Type:             "Gif",
	})
}

// ReplyVideoMessage sends a video message (round video) as reply
func (u *Update) ReplyVideoMessage(video interface{}, caption string) (*Update, error) {
	return u.Client.SendMessage(SendMessageOptions{
		ObjectGUID:       u.ObjectGUID(),
		Text:             caption,
		ReplyToMessageID: u.MessageID(),
		FileInline:       video,
		Type:             "VideoMessage",
	})
}

// Forward forwards this message to another chat
func (u *Update) Forward(toObjectGUID string) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.ForwardMessages(u.ObjectGUID(), toObjectGUID, []string{u.MessageID()})
}

// Forwards forwards multiple messages
func (u *Update) Forwards(toObjectGUID string, messageIDs []string) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	fromGUID := u.ObjectGUID()
	if messageIDs == nil {
		messageIDs = []string{u.MessageID()}
	}
	return u.Client.ForwardMessages(fromGUID, toObjectGUID, messageIDs)
}

// Edit edits this message
func (u *Update) Edit(text string) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.EditMessage(u.ObjectGUID(), u.MessageID(), text)
}

// Delete deletes this message
func (u *Update) Delete() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.DeleteMessages(u.ObjectGUID(), []string{u.MessageID()})
}

// DeleteMessages deletes multiple messages
func (u *Update) DeleteMessages(messageIDs []string) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	if messageIDs == nil {
		messageIDs = []string{u.MessageID()}
	}
	return u.Client.DeleteMessages(u.ObjectGUID(), messageIDs)
}

// Pin pins this message
func (u *Update) Pin() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.SetPinMessage(u.ObjectGUID(), u.MessageID(), "Pin")
}

// Unpin unpins this message
func (u *Update) Unpin() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.SetPinMessage(u.ObjectGUID(), u.MessageID(), "Unpin")
}

// Seen marks chat as seen
func (u *Update) Seen() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.SeenChats(map[string]string{
		u.ObjectGUID(): u.MessageID(),
	})
}

// Download downloads the file inline
func (u *Update) Download(saveAs string) ([]byte, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	fi := u.FileInline()
	if fi == nil {
		return nil, errors.New("no file_inline in this update")
	}
	return u.Client.DownloadFile(fi, saveAs)
}

// Reaction adds a reaction to this message
func (u *Update) Reaction(reactionID int) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.ActionOnMessageReaction(u.ObjectGUID(), u.MessageID(), "Add", reactionID)
}

// RemoveReaction removes reaction from this message
func (u *Update) RemoveReaction(reactionID int) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.ActionOnMessageReaction(u.ObjectGUID(), u.MessageID(), "Remove", reactionID)
}

// BanMember bans the author of this message
func (u *Update) BanMember() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	objectGUID := u.ObjectGUID()
	userGUID := u.AuthorGUID()
	if strings.HasPrefix(objectGUID, "g0") {
		return u.Client.BanGroupMember(objectGUID, userGUID, "Set")
	} else if strings.HasPrefix(objectGUID, "c0") {
		return u.Client.BanChannelMember(objectGUID, userGUID, "Set")
	}
	return nil, errors.New("cannot ban in private chat")
}

// UnbanMember unbans the author of this message
func (u *Update) UnbanMember() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	objectGUID := u.ObjectGUID()
	userGUID := u.AuthorGUID()
	if strings.HasPrefix(objectGUID, "g0") {
		return u.Client.BanGroupMember(objectGUID, userGUID, "Unset")
	} else if strings.HasPrefix(objectGUID, "c0") {
		return u.Client.BanChannelMember(objectGUID, userGUID, "Unset")
	}
	return nil, errors.New("cannot unban in private chat")
}

// Block blocks the user
func (u *Update) Block() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	userGUID := u.AuthorGUID()
	if userGUID == "" {
		userGUID = u.ObjectGUID()
	}
	return u.Client.SetBlockUser(userGUID)
}

// SendActivity sends typing/recording activity
func (u *Update) SendActivity(activity string) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	if activity == "" {
		activity = "Typing"
	}
	return u.Client.SendChatActivity(u.ObjectGUID(), activity)
}

// GetAuthor gets author's info
func (u *Update) GetAuthor() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.GetInfo(u.AuthorGUID())
}

// GetObject gets this chat's info
func (u *Update) GetObject() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	return u.Client.GetInfo(u.ObjectGUID())
}

// GetMessages gets messages by IDs
func (u *Update) GetMessages(messageIDs []string) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	if messageIDs == nil {
		messageIDs = []string{u.MessageID()}
	}
	return u.Client.GetMessagesByID(u.ObjectGUID(), messageIDs)
}

// GetReplyMessage gets the message being replied to
func (u *Update) GetReplyMessage() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	replyID := u.ReplyMessageID()
	if replyID == "" {
		return nil, nil
	}
	result, err := u.Client.GetMessagesByID(u.ObjectGUID(), []string{replyID})
	if err != nil {
		return nil, err
	}
	messages := result.GetSlice("messages")
	if len(messages) > 0 {
		if msg, ok := messages[0].(map[string]interface{}); ok {
			return NewUpdate(msg), nil
		}
	}
	return nil, nil
}

// GetReplyAuthor gets the author of the message being replied to
func (u *Update) GetReplyAuthor() (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}
	replyMsg, err := u.GetReplyMessage()
	if err != nil || replyMsg == nil {
		return nil, err
	}
	authorGUID := replyMsg.AuthorGUID()
	if authorGUID == "" {
		return nil, nil
	}
	return u.Client.GetInfo(authorGUID)
}

// IsAdmin checks if user is admin in this chat
func (u *Update) IsAdmin(userGUID string) (bool, error) {
	if u.Client == nil {
		return false, ErrNoConnection
	}
	if userGUID == "" {
		userGUID = u.AuthorGUID()
	}
	objectGUID := u.ObjectGUID()

	if strings.HasPrefix(objectGUID, "g0") {
		result, err := u.Client.GetGroupAdminMembers(objectGUID)
		if err != nil {
			return false, err
		}
		members := result.GetSlice("in_chat_members")
		for _, m := range members {
			if member, ok := m.(map[string]interface{}); ok {
				if guid, ok := member["member_guid"].(string); ok && guid == userGUID {
					return true, nil
				}
			}
		}
	} else if strings.HasPrefix(objectGUID, "c0") {
		result, err := u.Client.GetChannelAdminMembers(objectGUID)
		if err != nil {
			return false, err
		}
		members := result.GetSlice("in_chat_members")
		for _, m := range members {
			if member, ok := m.(map[string]interface{}); ok {
				if guid, ok := member["member_guid"].(string); ok && guid == userGUID {
					return true, nil
				}
			}
		}
	}

	return false, nil
}

// Copy copies message to another chat
func (u *Update) Copy(toObjectGUID string) (*Update, error) {
	if u.Client == nil {
		return nil, ErrNoConnection
	}

	// Get the original message
	result, err := u.Client.GetMessagesByID(u.ObjectGUID(), []string{u.MessageID()})
	if err != nil {
		return nil, err
	}

	messages := result.GetSlice("messages")
	if len(messages) == 0 {
		return nil, errors.New("message not found")
	}

	msg, ok := messages[0].(map[string]interface{})
	if !ok {
		return nil, errors.New("invalid message format")
	}

	msgUpdate := NewUpdate(msg)
	msgUpdate.Client = u.Client

	text := msgUpdate.Text()
	sticker := msgUpdate.Sticker()
	fileInline := msgUpdate.FileInline()

	if sticker != nil {
		return u.Client.SendMessage(SendMessageOptions{
			ObjectGUID: toObjectGUID,
			Sticker:    sticker.Data,
		})
	}

	if fileInline != nil {
		fileType := fileInline.GetString("type")
		if fileType != "Gif" && fileType != "Sticker" {
			// Download and re-upload
			data, err := u.Client.DownloadFile(fileInline, "")
			if err != nil {
				return nil, err
			}
			return u.Client.SendMessage(SendMessageOptions{
				ObjectGUID: toObjectGUID,
				Text:       text,
				FileInline: data,
				Type:       fileType,
				FileName:   fileInline.GetString("file_name"),
			})
		}
		return u.Client.SendMessage(SendMessageOptions{
			ObjectGUID: toObjectGUID,
			Text:       text,
			FileInline: fileInline.Data,
			Type:       fileType,
		})
	}

	return u.Client.SendMessage(SendMessageOptions{
		ObjectGUID: toObjectGUID,
		Text:       text,
	})
}

// ═══════════════════════════════════════════════════════════════════════════════
//  Session Types
// ═══════════════════════════════════════════════════════════════════════════════

// SQLiteSession - SQLite based session storage
type SQLiteSession struct {
	name string
	db   *sql.DB
}

func NewSQLiteSession(name string) (*SQLiteSession, error) {
	dbPath := name
	if !strings.HasSuffix(dbPath, ".db") && !strings.HasSuffix(dbPath, ".sqlite") {
		dbPath = name + ".session"
	}

	db, err := sql.Open("sqlite", dbPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open sqlite database: %w", err)
	}

	if _, err := db.Exec("PRAGMA journal_mode=WAL"); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to set WAL mode: %w", err)
	}

	_, err = db.Exec(`
		CREATE TABLE IF NOT EXISTS session (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			auth TEXT NOT NULL DEFAULT '',
			guid TEXT NOT NULL DEFAULT '',
			user_agent TEXT NOT NULL DEFAULT '',
			phone_number TEXT NOT NULL DEFAULT '',
			private_key TEXT NOT NULL DEFAULT ''
		)
	`)
	if err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to create session table: %w", err)
	}

	return &SQLiteSession{name: name, db: db}, nil
}

type SessionInfo struct {
	ID          int64
	Auth        string
	GUID        string
	UserAgent   string
	PhoneNumber string
	PrivateKey  string
}

func (s *SQLiteSession) Information() *SessionInfo {
	row := s.db.QueryRow(
		"SELECT id, auth, guid, user_agent, phone_number, private_key FROM session ORDER BY id DESC LIMIT 1",
	)
	info := &SessionInfo{}
	err := row.Scan(&info.ID, &info.Auth, &info.GUID, &info.UserAgent, &info.PhoneNumber, &info.PrivateKey)
	if err != nil {
		return nil
	}
	if info.Auth == "" {
		return nil
	}
	return info
}

func (s *SQLiteSession) Insert(auth, guid, userAgent, phoneNumber, privateKey string) error {
	tx, err := s.db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	if _, err := tx.Exec("DELETE FROM session"); err != nil {
		return err
	}
	if _, err := tx.Exec(
		"INSERT INTO session (auth, guid, user_agent, phone_number, private_key) VALUES (?, ?, ?, ?, ?)",
		auth, guid, userAgent, phoneNumber, privateKey,
	); err != nil {
		return err
	}
	return tx.Commit()
}

func (s *SQLiteSession) Close() error {
	if s.db != nil {
		return s.db.Close()
	}
	return nil
}

// StringSession - String based session (for bot deployments)
type StringSession struct {
	Auth       string
	GUID       string
	UserAgent  string
	PrivateKey string
}

// NewStringSession creates a session from encoded string
func NewStringSession(sessionString string) (*StringSession, error) {
	if sessionString == "" {
		return &StringSession{}, nil
	}

	decoded, err := base64.StdEncoding.DecodeString(sessionString)
	if err != nil {
		return nil, fmt.Errorf("invalid session string: %w", err)
	}

	var data map[string]string
	if err := json.Unmarshal(decoded, &data); err != nil {
		return nil, fmt.Errorf("invalid session format: %w", err)
	}

	return &StringSession{
		Auth:       data["auth"],
		GUID:       data["guid"],
		UserAgent:  data["user_agent"],
		PrivateKey: data["private_key"],
	}, nil
}

// Encode encodes session to string
func (s *StringSession) Encode() (string, error) {
	data := map[string]string{
		"auth":        s.Auth,
		"guid":        s.GUID,
		"user_agent":  s.UserAgent,
		"private_key": s.PrivateKey,
	}
	jsonData, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(jsonData), nil
}

func (s *StringSession) Information() *SessionInfo {
	if s.Auth == "" {
		return nil
	}
	return &SessionInfo{
		Auth:       s.Auth,
		GUID:       s.GUID,
		UserAgent:  s.UserAgent,
		PrivateKey: s.PrivateKey,
	}
}

func (s *StringSession) Insert(auth, guid, userAgent, phoneNumber, privateKey string) error {
	s.Auth = auth
	s.GUID = guid
	s.UserAgent = userAgent
	s.PrivateKey = privateKey
	return nil
}

func (s *StringSession) Close() error {
	return nil
}

// Session interface for both session types
type Session interface {
	Information() *SessionInfo
	Insert(auth, guid, userAgent, phoneNumber, privateKey string) error
	Close() error
}

// ═══════════════════════════════════════════════════════════════════════════════
//  Network
// ═══════════════════════════════════════════════════════════════════════════════

type Network struct {
	client       *RubClient
	maxRetries   int
	httpClient   *http.Client
	headers      map[string]string
	apiURL       string
	wssURL       string
	wsConn       *websocket.Conn
	wsMu         sync.Mutex
	apiMap       map[string]string
	apiPriority  []string
	apiCodeByURL map[string]string
	cryptoHelper *CryptoHelper
}

func NewNetwork(client *RubClient) *Network {
	headers := map[string]string{
		"origin":       "https://m.rubika.ir",
		"referer":      "https://m.rubika.ir/",
		"content-type": "application/json",
		"connection":   "keep-alive",
		"user-agent":   client.UserAgent,
	}

	transport := &http.Transport{
		MaxIdleConnsPerHost: 100,
		IdleConnTimeout:     90 * time.Second,
	}

	if client.Proxy != "" {
		proxyURL, err := url.Parse(client.Proxy)
		if err == nil {
			transport.Proxy = http.ProxyURL(proxyURL)
		}
	}

	if client.DefaultPlatform["platform"] == "Android" {
		delete(headers, "origin")
		delete(headers, "referer")
		headers["user-agent"] = "okhttp/3.12.1"
		client.DefaultPlatform["package"] = "app.rbmain.a"
		client.DefaultPlatform["app_version"] = "3.8.2"
	}

	return &Network{
		client:       client,
		maxRetries:   client.MaxRetries,
		httpClient:   &http.Client{Timeout: client.Timeout, Transport: transport},
		headers:      headers,
		apiMap:       make(map[string]string),
		apiPriority:  []string{},
		apiCodeByURL: make(map[string]string),
		cryptoHelper: NewCrypto(),
	}
}

func (n *Network) normalizeURL(u string) string {
	if u == "" {
		return ""
	}
	return strings.TrimRight(u, "/")
}

func (n *Network) ensureTrailingSlash(u string) string {
	if u == "" || strings.HasSuffix(u, "/") {
		return u
	}
	return u + "/"
}

func (n *Network) isManagedAPI(u string) bool {
	normalized := n.normalizeURL(u)
	if normalized == "" {
		return false
	}
	_, ok := n.apiCodeByURL[normalized]
	return ok
}

func (n *Network) candidateAPIURLs(preferred string) []string {
	var candidates []string
	seen := make(map[string]bool)

	addCandidate := func(candidate string) {
		if candidate == "" {
			return
		}
		normalized := n.normalizeURL(candidate)
		if normalized == "" || seen[normalized] {
			return
		}
		seen[normalized] = true
		if n.isManagedAPI(candidate) {
			candidates = append(candidates, n.ensureTrailingSlash(normalized))
		} else {
			candidates = append(candidates, candidate)
		}
	}

	addCandidate(preferred)
	if preferred != "" && !n.isManagedAPI(preferred) {
		return candidates
	}

	for _, code := range n.apiPriority {
		if ep, ok := n.apiMap[code]; ok {
			addCandidate(ep)
		}
	}
	for _, ep := range n.apiMap {
		addCandidate(ep)
	}
	return candidates
}

func (n *Network) promoteAPI(u string) {
	normalized := n.normalizeURL(u)
	if normalized == "" {
		return
	}
	code, ok := n.apiCodeByURL[normalized]
	if !ok {
		return
	}
	newPriority := []string{code}
	for _, c := range n.apiPriority {
		if c != code {
			newPriority = append(newPriority, c)
		}
	}
	n.apiPriority = newPriority
	if ep, ok := n.apiMap[code]; ok {
		n.apiURL = ep
	} else {
		n.apiURL = n.ensureTrailingSlash(normalized)
	}
}

func exponentialBackoff(attempt int) time.Duration {
	return time.Duration(math.Pow(2, float64(attempt))) * time.Second
}

func (n *Network) GetDCs() error {
	dcURL := "https://getdcmess.iranlms.ir/"

	for attempt := 0; attempt < 3; attempt++ {
		req, err := http.NewRequest("GET", dcURL, nil)
		if err != nil {
			continue
		}
		for k, v := range n.headers {
			req.Header.Set(k, v)
		}

		resp, err := n.httpClient.Do(req)
		if err != nil {
			log.Printf("Failed to retrieve DCs (attempt %d/3): %v", attempt+1, err)
			time.Sleep(exponentialBackoff(attempt))
			continue
		}

		body, err := io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			continue
		}

		var jsonData map[string]interface{}
		if err := json.Unmarshal(body, &jsonData); err != nil {
			continue
		}

		data, ok := jsonData["data"].(map[string]interface{})
		if !ok {
			continue
		}

		apiList, _ := data["API"].(map[string]interface{})
		socketList, _ := data["socket"].(map[string]interface{})

		n.apiMap = make(map[string]string)
		for code, endpoint := range apiList {
			ep, ok := endpoint.(string)
			if !ok || ep == "" {
				continue
			}
			n.apiMap[code] = n.ensureTrailingSlash(strings.TrimRight(ep, "/"))
		}

		n.apiCodeByURL = make(map[string]string)
		for code, u := range n.apiMap {
			normalized := n.normalizeURL(u)
			if normalized != "" {
				n.apiCodeByURL[normalized] = code
			}
		}

		var preferredCodes []string
		if defaultAPIs, ok := data["default_apis"].([]interface{}); ok {
			for _, c := range defaultAPIs {
				cs := fmt.Sprintf("%v", c)
				if _, exists := n.apiMap[cs]; exists {
					found := false
					for _, pc := range preferredCodes {
						if pc == cs {
							found = true
							break
						}
					}
					if !found {
						preferredCodes = append(preferredCodes, cs)
					}
				}
			}
		}

		if defaultAPI, ok := data["default_api"]; ok {
			cs := fmt.Sprintf("%v", defaultAPI)
			if _, exists := n.apiMap[cs]; exists {
				found := false
				for _, pc := range preferredCodes {
					if pc == cs {
						found = true
						break
					}
				}
				if !found {
					preferredCodes = append([]string{cs}, preferredCodes...)
				}
			}
		}

		if len(preferredCodes) == 0 {
			for k := range n.apiMap {
				preferredCodes = append(preferredCodes, k)
			}
		}

		n.apiPriority = preferredCodes
		if len(n.apiPriority) > 0 {
			if ep, ok := n.apiMap[n.apiPriority[0]]; ok {
				n.apiURL = ep
			}
		}

		if defaultSocket, ok := data["default_socket"]; ok {
			ds := fmt.Sprintf("%v", defaultSocket)
			if wss, ok := socketList[ds]; ok {
				n.wssURL = fmt.Sprintf("%v", wss)
			}
		}

		if n.apiURL != "" && n.wssURL != "" {
			return nil
		}
	}
	return ErrNetworkError
}

func (n *Network) doRequest(targetURL string, data interface{}) (map[string]interface{}, error) {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}

	candidates := n.candidateAPIURLs(targetURL)
	if len(candidates) == 0 {
		if targetURL != "" {
			candidates = []string{targetURL}
		} else {
			return nil, errors.New("no API endpoints available")
		}
	}

	var lastErr error

	for _, candidate := range candidates {
		for attempt := 0; attempt < n.maxRetries; attempt++ {
			req, err := http.NewRequest("POST", candidate, bytes.NewReader(jsonData))
			if err != nil {
				lastErr = err
				continue
			}
			for k, v := range n.headers {
				req.Header.Set(k, v)
			}

			resp, err := n.httpClient.Do(req)
			if err != nil {
				lastErr = err
				log.Printf("Request to %s failed (attempt %d/%d): %v",
					candidate, attempt+1, n.maxRetries, err)
				time.Sleep(exponentialBackoff(attempt))
				continue
			}

			body, err := io.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				lastErr = err
				continue
			}

			var result map[string]interface{}
			if err := json.Unmarshal(body, &result); err != nil {
				lastErr = err
				continue
			}

			n.promoteAPI(candidate)
			return result, nil
		}
	}

	return nil, fmt.Errorf("request failed after trying %d endpoint(s): %w",
		len(candidates), lastErr)
}

type SendOpts struct {
	APIVersion string
	Auth       string
	ClientInfo map[string]string
	Input      map[string]interface{}
	Method     string
	Encrypt    bool
	TmpSession bool
	URL        string
}

func (n *Network) Send(opts SendOpts) (map[string]interface{}, error) {
	if opts.APIVersion == "" {
		opts.APIVersion = n.client.APIVersion
	}
	if opts.Auth == "" {
		opts.Auth = n.client.Auth
	}
	if opts.ClientInfo == nil {
		opts.ClientInfo = n.client.DefaultPlatform
	}
	if opts.Input == nil {
		opts.Input = make(map[string]interface{})
	}
	if opts.Method == "" {
		opts.Method = "getUserInfo"
	}
	if opts.URL == "" {
		opts.URL = n.apiURL
	}

	data := map[string]interface{}{
		"api_version": opts.APIVersion,
	}

	if opts.TmpSession {
		data["tmp_session"] = opts.Auth
	} else {
		data["auth"] = n.client.DecodeAuthStr
	}

	if opts.APIVersion == "6" {
		clientMap := make(map[string]interface{})
		for k, v := range opts.ClientInfo {
			clientMap[k] = v
		}
		dataEnc := map[string]interface{}{
			"client": clientMap,
			"method": opts.Method,
			"input":  opts.Input,
		}

		if opts.Encrypt {
			encrypted, err := n.cryptoHelper.Encrypt(dataEnc, n.client.Key)
			if err != nil {
				return nil, fmt.Errorf("encryption error: %w", err)
			}
			data["data_enc"] = encrypted

			if !opts.TmpSession && n.client.ImportKey != nil {
				sign, err := n.cryptoHelper.Sign(n.client.ImportKey, encrypted)
				if err != nil {
					return nil, fmt.Errorf("sign error: %w", err)
				}
				data["sign"] = sign
			}
		}

		return n.doRequest(opts.URL, data)
	}

	return n.doRequest(opts.URL, data)
}

func (n *Network) Close() error {
	n.wsMu.Lock()
	defer n.wsMu.Unlock()
	if n.wsConn != nil {
		err := n.wsConn.Close()
		n.wsConn = nil
		return err
	}
	return nil
}

func (n *Network) GetUpdates(stopCh <-chan struct{}) {
	go n.keepSocket(stopCh)

	for {
		select {
		case <-stopCh:
			return
		default:
		}

		dialer := websocket.Dialer{
			HandshakeTimeout: 10 * time.Second,
		}
		if n.client.Proxy != "" {
			proxyURL, err := url.Parse(n.client.Proxy)
			if err == nil {
				dialer.Proxy = http.ProxyURL(proxyURL)
			}
		}

		conn, _, err := dialer.Dial(n.wssURL, nil)
		if err != nil {
			log.Printf("WebSocket connection failed: %v. Retrying in 3s...", err)
			time.Sleep(3 * time.Second)
			continue
		}

		n.wsMu.Lock()
		n.wsConn = conn
		n.wsMu.Unlock()

		handshake := map[string]interface{}{
			"method":      "handShake",
			"auth":        n.client.Auth,
			"api_version": "6",
			"data":        "",
		}
		if err := conn.WriteJSON(handshake); err != nil {
			log.Printf("Handshake failed: %v", err)
			conn.Close()
			continue
		}

		for {
			select {
			case <-stopCh:
				conn.Close()
				return
			default:
			}

			_, message, err := conn.ReadMessage()
			if err != nil {
				log.Printf("WebSocket read error: %v. Reconnecting...", err)
				conn.Close()
				break
			}

			var msgData map[string]interface{}
			if err := json.Unmarshal(message, &msgData); err != nil {
				continue
			}

			go n.handleTextMessage(msgData)
		}
	}
}

func (n *Network) keepSocket(stopCh <-chan struct{}) {
	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-stopCh:
			return
		case <-ticker.C:
			n.wsMu.Lock()
			ws := n.wsConn
			n.wsMu.Unlock()

			if ws != nil {
				if err := ws.WriteJSON(map[string]interface{}{}); err != nil {
					log.Printf("Keep-alive failed: %v", err)
				}
				go func() {
					if _, err := n.client.GetChatsUpdates(); err != nil {
						log.Printf("GetChatsUpdates error: %v", err)
					}
				}()
			}
		}
	}
}

func (n *Network) handleTextMessage(msgData map[string]interface{}) {
	dataEnc, ok := msgData["data_enc"].(string)
	if !ok || dataEnc == "" {
		return
	}

	decrypted, err := n.cryptoHelper.Decrypt(dataEnc, n.client.Key)
	if err != nil {
		log.Printf("Decrypt error: %v", err)
		return
	}

	userGUID, _ := decrypted["user_guid"].(string)
	delete(decrypted, "user_guid")

	for name, updates := range decrypted {
		updateList, ok := updates.([]interface{})
		if !ok {
			continue
		}
		for _, upd := range updateList {
			updMap, ok := upd.(map[string]interface{})
			if !ok {
				continue
			}
			updMap["client"] = n.client
			updMap["user_guid"] = userGUID
			n.handleUpdate(name, updMap)
		}
	}
}

func (n *Network) handleUpdate(name string, updateData map[string]interface{}) {
	capitalizedName := capitalizeStr(name)

	n.client.handlersMu.RLock()
	defer n.client.handlersMu.RUnlock()

	for _, handler := range n.client.handlers {
		if handler.Name != capitalizedName {
			continue
		}

		if handler.Filter != nil && !handler.Filter(updateData) {
			continue
		}

		update := NewUpdate(updateData)
		update.Client = n.client

		if handler.Func != nil {
			if n.client.SequentialHandlers {
				handler.Func(update)
				break
			} else {
				go handler.Func(update)
			}
		}
	}
}

func (n *Network) UploadFile(
	file interface{},
	fileName string,
	mimeType string,
	chunk int,
	callback func(total, current int64),
) (*Update, error) {
	var fileData []byte
	var fileSize int64

	switch f := file.(type) {
	case string:
		data, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("file not found: %w", err)
		}
		fileData = data
		fileSize = int64(len(data))
		if fileName == "" {
			fileName = filepath.Base(f)
		}
	case []byte:
		if fileName == "" {
			return nil, errors.New("file_name must be specified when uploading from bytes")
		}
		fileData = f
		fileSize = int64(len(f))
	default:
		return nil, errors.New("file must be a file path (string) or raw bytes")
	}

	if mimeType == "" {
		ext := filepath.Ext(fileName)
		if ext != "" {
			mimeType = ext[1:]
		}
	}

	if chunk <= 0 {
		chunk = DefaultChunkSize
	}

	result, err := n.client.RequestSendFile(fileName, fileSize, mimeType)
	if err != nil {
		return nil, err
	}

	fileID := result.GetString("id")
	dcID := result.GetString("dc_id")
	uploadURL := result.GetString("upload_url")
	accessHashSend := result.GetString("access_hash_send")

	totalParts := (fileSize + int64(chunk) - 1) / int64(chunk)

	var uploadResult map[string]interface{}

	for index := int64(0); index < totalParts; index++ {
		start := index * int64(chunk)
		end := start + int64(chunk)
		if end > fileSize {
			end = fileSize
		}
		chunkData := fileData[start:end]

		for attempt := 0; attempt < n.maxRetries; attempt++ {
			req, err := http.NewRequest("POST", uploadURL, bytes.NewReader(chunkData))
			if err != nil {
				continue
			}
			req.Header.Set("auth", n.client.Auth)
			req.Header.Set("file-id", fileID)
			req.Header.Set("total-part", fmt.Sprintf("%d", totalParts))
			req.Header.Set("part-number", fmt.Sprintf("%d", index+1))
			req.Header.Set("chunk-size", fmt.Sprintf("%d", len(chunkData)))
			req.Header.Set("access-hash-send", accessHashSend)

			resp, err := n.httpClient.Do(req)
			if err != nil {
				if attempt < n.maxRetries-1 {
					time.Sleep(exponentialBackoff(attempt))
					continue
				}
				return nil, err
			}

			body, err := io.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				continue
			}

			if err := json.Unmarshal(body, &uploadResult); err != nil {
				continue
			}

			if status, _ := uploadResult["status"].(string); status == "ERROR_TRY_AGAIN" {
				result, err = n.client.RequestSendFile(fileName, fileSize, mimeType)
				if err != nil {
					return nil, err
				}
				fileID = result.GetString("id")
				dcID = result.GetString("dc_id")
				uploadURL = result.GetString("upload_url")
				accessHashSend = result.GetString("access_hash_send")
				index = -1
				break
			}

			break
		}

		if callback != nil {
			current := end
			if current > fileSize {
				current = fileSize
			}
			callback(fileSize, current)
		}
	}

	if uploadResult != nil {
		status, _ := uploadResult["status"].(string)
		statusDet, _ := uploadResult["status_det"].(string)
		if status == "OK" && statusDet == "OK" {
			dataMap, _ := uploadResult["data"].(map[string]interface{})
			accessHashRec := ""
			if dataMap != nil {
				accessHashRec, _ = dataMap["access_hash_rec"].(string)
			}
			return NewUpdate(map[string]interface{}{
				"mime":            mimeType,
				"size":            fileSize,
				"dc_id":           dcID,
				"file_id":         fileID,
				"file_name":       fileName,
				"access_hash_rec": accessHashRec,
			}), nil
		}
	}

	return nil, fmt.Errorf("upload failed: %v", uploadResult)
}

func (n *Network) Download(
	dcID, fileID, accessHash string,
	size int64,
	chunk int,
	callback func(total, current int64),
	saveAs string,
) ([]byte, error) {
	if chunk <= 0 {
		chunk = DownloadChunk
	}

	baseURL := fmt.Sprintf("https://messenger%s.iranlms.ir", dcID)

	if saveAs != "" {
		f, err := os.Create(saveAs)
		if err != nil {
			return nil, err
		}
		defer f.Close()

		for start := int64(0); start < size; start += int64(chunk) {
			end := start + int64(chunk)
			if end > size {
				end = size
			}
			data, err := n.fetchChunk(baseURL, fileID, accessHash, start, end-1)
			if err != nil {
				return nil, err
			}
			if _, err := f.Write(data); err != nil {
				return nil, err
			}
			if callback != nil {
				callback(size, end)
			}
		}
		return nil, nil
	}

	var result []byte
	for start := int64(0); start < size; start += int64(chunk) {
		end := start + int64(chunk)
		if end > size {
			end = size
		}
		data, err := n.fetchChunk(baseURL, fileID, accessHash, start, end-1)
		if err != nil {
			return nil, err
		}
		result = append(result, data...)
		if callback != nil {
			callback(size, int64(len(result)))
		}
	}

	return result, nil
}

func (n *Network) fetchChunk(baseURL, fileID, accessHash string, start, end int64) ([]byte, error) {
	for attempt := 0; attempt < n.maxRetries; attempt++ {
		req, err := http.NewRequest("POST", baseURL+"/GetFile.ashx", nil)
		if err != nil {
			continue
		}
		req.Header.Set("auth", n.client.Auth)
		req.Header.Set("access-hash-rec", accessHash)
		req.Header.Set("file-id", fileID)
		req.Header.Set("user-agent", n.client.UserAgent)
		req.Header.Set("start-index", fmt.Sprintf("%d", start))
		req.Header.Set("last-index", fmt.Sprintf("%d", end))

		resp, err := n.httpClient.Do(req)
		if err != nil {
			time.Sleep(exponentialBackoff(attempt))
			continue
		}

		data, err := io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			continue
		}

		if resp.StatusCode == 200 {
			return data, nil
		}
	}
	return nil, errors.New("download chunk failed after retries")
}

// ═══════════════════════════════════════════════════════════════════════════════
//  Handler
// ═══════════════════════════════════════════════════════════════════════════════

type Handler struct {
	Name   string
	Func   func(*Update)
	Filter func(map[string]interface{}) bool
}

// ═══════════════════════════════════════════════════════════════════════════════
//  RubClient
// ═══════════════════════════════════════════════════════════════════════════════

type RubClient struct {
	Name               string
	Auth               string
	GUID               string
	Key                string
	DecodeAuthStr      string
	PrivateKey         string
	ImportKey          *rsa.PrivateKey
	PhoneNumber        string
	UserAgent          string
	LangCode           string
	Timeout            time.Duration
	ParseMode          string
	Proxy              string
	APIVersion         string
	MaxRetries         int
	SequentialHandlers bool
	DisplayWelcome     bool

	DefaultPlatform map[string]string

	session        Session
	connection     *Network
	cryptoHelper   *CryptoHelper
	markdown       *MarkdownParser
	mediaThumbnail *MediaThumbnail
	audio          *Audio
	handlers       []Handler
	handlersMu     sync.RWMutex
	stopCh         chan struct{}
	logger         *log.Logger
}

type ClientOption func(*RubClient)

func WithAuth(auth string) ClientOption        { return func(c *RubClient) { c.Auth = auth } }
func WithPrivateKey(pk string) ClientOption    { return func(c *RubClient) { c.PrivateKey = pk } }
func WithPhoneNumber(pn string) ClientOption   { return func(c *RubClient) { c.PhoneNumber = pn } }
func WithUserAgent(ua string) ClientOption     { return func(c *RubClient) { c.UserAgent = ua } }
func WithTimeout(t time.Duration) ClientOption { return func(c *RubClient) { c.Timeout = t } }
func WithLangCode(lc string) ClientOption      { return func(c *RubClient) { c.LangCode = lc } }
func WithParseMode(pm string) ClientOption     { return func(c *RubClient) { c.ParseMode = pm } }
func WithProxy(p string) ClientOption          { return func(c *RubClient) { c.Proxy = p } }
func WithMaxRetries(mr int) ClientOption       { return func(c *RubClient) { c.MaxRetries = mr } }
func WithDisplayWelcome(dw bool) ClientOption  { return func(c *RubClient) { c.DisplayWelcome = dw } }

func WithPlatform(p string) ClientOption {
	return func(c *RubClient) {
		if strings.EqualFold(p, "android") {
			c.DefaultPlatform["platform"] = "Android"
		}
	}
}

func WithSequentialHandlers(sh bool) ClientOption {
	return func(c *RubClient) { c.SequentialHandlers = sh }
}

func WithStringSession(ss *StringSession) ClientOption {
	return func(c *RubClient) {
		c.session = ss
	}
}

func NewClient(name string, opts ...ClientOption) (*RubClient, error) {
	c := &RubClient{
		Name:       name,
		UserAgent:  DefaultUserAgent,
		LangCode:   "fa",
		Timeout:    DefaultTimeout,
		ParseMode:  "markdown",
		APIVersion: DefaultAPIVersion,
		MaxRetries: 5,
		DefaultPlatform: map[string]string{
			"app_name":    "Main",
			"app_version": "2.4.6",
			"platform":    "PWA",
			"package":     "m.rubika.ir",
		},
		cryptoHelper:   NewCrypto(),
		markdown:       NewMarkdownParser(),
		mediaThumbnail: NewMediaThumbnail(),
		audio:          NewAudio(),
		logger:         log.New(os.Stdout, "[rubpy] ", log.LstdFlags),
		stopCh:         make(chan struct{}),
	}

	for _, opt := range opts {
		opt(c)
	}

	c.DefaultPlatform["lang_code"] = c.LangCode

	// Create session if not set via WithStringSession
	if c.session == nil {
		session, err := NewSQLiteSession(name)
		if err != nil {
			return nil, fmt.Errorf("failed to create session: %w", err)
		}
		c.session = session
	}

	if c.DisplayWelcome {
		c.logger.Println("Rubika client initialized successfully.")
	}

	return c, nil
}

// NewClientWithStringSession creates a client with string session
func NewClientWithStringSession(sessionString string, opts ...ClientOption) (*RubClient, error) {
	ss, err := NewStringSession(sessionString)
	if err != nil {
		return nil, err
	}

	opts = append(opts, WithStringSession(ss))
	return NewClient("string_session", opts...)
}

func (c *RubClient) Connect() error {
	c.connection = NewNetwork(c)
	info := c.session.Information()

	if info != nil {
		c.Auth = info.Auth
		c.GUID = info.GUID
		c.PrivateKey = info.PrivateKey
		if info.UserAgent != "" {
			c.UserAgent = info.UserAgent
		}
		c.logger.Printf("Session loaded: auth=%s guid=%s", truncate(c.Auth, 8), c.GUID)
	}

	return nil
}

func (c *RubClient) Builder(
	name string,
	tmpSession bool,
	encrypt bool,
	input map[string]interface{},
) (*Update, error) {
	if c.connection == nil {
		return nil, ErrNoConnection
	}

	if c.connection.apiURL == "" {
		if err := c.connection.GetDCs(); err != nil {
			return nil, fmt.Errorf("failed to get DCs: %w", err)
		}
	}

	if c.Auth == "" {
		c.Auth = c.cryptoHelper.Secret(32)
		c.logger.Printf("Created auth secret: %s", truncate(c.Auth, 8))
	}

	if c.Key == "" {
		c.Key = c.cryptoHelper.Passphrase(c.Auth)
	}

	if c.DecodeAuthStr == "" && c.Auth != "" {
		c.DecodeAuthStr = c.cryptoHelper.DecodeAuth(c.Auth)
	}

	if input == nil {
		input = make(map[string]interface{})
	}

	result, err := c.connection.Send(SendOpts{
		Method:     name,
		TmpSession: tmpSession,
		Encrypt:    encrypt,
		Input:      input,
	})
	if err != nil {
		return nil, err
	}

	if result == nil {
		return nil, errors.New("nil response from server")
	}

	if dataEnc, ok := result["data_enc"].(string); ok {
		decrypted, err := c.cryptoHelper.Decrypt(dataEnc, c.Key)
		if err != nil {
			return nil, fmt.Errorf("decrypt error: %w", err)
		}
		result = decrypted
	}

	status, _ := result["status"].(string)
	statusDet, _ := result["status_det"].(string)

	if status == "OK" && statusDet == "OK" {
		data, _ := result["data"].(map[string]interface{})
		if data == nil {
			data = make(map[string]interface{})
		}
		data["_client"] = c
		return NewUpdate(data), nil
	}

	if statusDet == "NOT_REGISTERED" {
		return nil, ErrNotRegistered
	}

	return nil, &RequestError{
		Status:    status,
		StatusDet: statusDet,
		Data:      result,
	}
}

// ─── API Methods ────────────────────────────

func (c *RubClient) GetUserInfo(userGUID string) (*Update, error) {
	input := make(map[string]interface{})
	if userGUID != "" {
		input["user_guid"] = userGUID
	}
	tmpSession := c.ImportKey == nil
	return c.Builder("getUserInfo", tmpSession, true, input)
}

func (c *RubClient) GetMe() (*Update, error) {
	return c.GetUserInfo("")
}

func (c *RubClient) SendCode(phoneNumber, passKey, sendType string) (*Update, error) {
	if sendType == "" {
		sendType = "SMS"
	}
	if sendType != "SMS" && sendType != "Internal" {
		return nil, errors.New("send_type can only be 'SMS' or 'Internal'")
	}
	input := map[string]interface{}{
		"phone_number": phoneNumber,
		"send_type":    sendType,
	}
	if passKey != "" {
		input["pass_key"] = passKey
	}
	return c.Builder("sendCode", true, true, input)
}

func (c *RubClient) SignIn(phoneCode, phoneNumber, phoneCodeHash, publicKey string) (*Update, error) {
	return c.Builder("signIn", true, true, map[string]interface{}{
		"phone_code":      phoneCode,
		"phone_number":    phoneNumber,
		"phone_code_hash": phoneCodeHash,
		"public_key":      publicKey,
	})
}

func (c *RubClient) RegisterDevice(deviceModel string) (*Update, error) {
	input := c.getBrowserPlatform(deviceModel)
	return c.Builder("registerDevice", false, true, input)
}

func (c *RubClient) getBrowserPlatform(deviceModel string) map[string]interface{} {
	ua := c.UserAgent
	var dm string
	re := regexp.MustCompile(`(?i)(opera|chrome|safari|firefox|msie|trident)/(\d+)`)
	match := re.FindStringSubmatch(strings.ToLower(ua))
	if len(match) >= 3 {
		dm = strings.Title(match[1]) + " " + match[2]
	} else {
		dm = "Unknown"
	}

	systemVersion := "Unknown"
	sysVersions := map[string]string{
		"Windows NT 10.0": "Windows 10",
		"Windows NT 6.2":  "Windows 8",
		"Windows NT 6.1":  "Windows 7",
		"Windows NT 6.0":  "Windows Vista",
		"Windows NT 5.1":  "Windows XP",
		"Windows NT 5.0":  "Windows 2000",
		"Mac":             "Mac/iOS",
		"X11":             "UNIX",
		"Linux":           "Linux",
	}
	for key, value := range sysVersions {
		if strings.Contains(ua, key) {
			systemVersion = value
			break
		}
	}

	if deviceModel != "" {
		dm = deviceModel
	}

	digitRE := regexp.MustCompile(`\d+`)
	digits := strings.Join(digitRE.FindAllString(ua, -1), "")

	return map[string]interface{}{
		"token":          "",
		"lang_code":      c.LangCode,
		"token_type":     "Firebase",
		"app_version":    "PW_" + c.DefaultPlatform["app_version"],
		"system_version": systemVersion,
		"device_model":   dm,
		"device_hash":    "2" + digits,
	}
}

func (c *RubClient) getAndroidPlatform(deviceModel string) map[string]interface{} {
	digitRE := regexp.MustCompile(`\d+`)
	digits := strings.Join(digitRE.FindAllString(c.UserAgent, -1), "")

	return map[string]interface{}{
		"token":          "",
		"lang_code":      c.LangCode,
		"token_type":     "Firebase",
		"app_version":    "MA_" + c.DefaultPlatform["app_version"],
		"system_version": "SDK 22",
		"device_model":   "samsungSM-G925F",
		"device_hash":    "2" + digits,
	}
}

func (c *RubClient) RequestSendFile(fileName string, fileSize int64, mimeType string) (*Update, error) {
	return c.Builder("requestSendFile", false, true, map[string]interface{}{
		"file_name": fileName,
		"size":      fileSize,
		"mime":      mimeType,
	})
}

func (c *RubClient) GetChatsUpdates() (*Update, error) {
	return c.Builder("getChatsUpdates", false, true, map[string]interface{}{
		"state": time.Now().Unix(),
	})
}

func (c *RubClient) DeleteMessages(objectGUID string, messageIDs []string) (*Update, error) {
	return c.Builder("deleteMessages", false, true, map[string]interface{}{
		"object_guid": objectGUID,
		"message_ids": messageIDs,
	})
}

func (c *RubClient) ForwardMessages(fromObjectGUID, toObjectGUID string, messageIDs []string) (*Update, error) {
	return c.Builder("forwardMessages", false, true, map[string]interface{}{
		"from_object_guid": fromObjectGUID,
		"to_object_guid":   toObjectGUID,
		"message_ids":      messageIDs,
	})
}

func (c *RubClient) EditMessage(objectGUID, messageID, text string) (*Update, error) {
	return c.Builder("editMessage", false, true, map[string]interface{}{
		"object_guid": objectGUID,
		"message_id":  messageID,
		"text":        text,
	})
}

func (c *RubClient) GetMessagesByID(objectGUID string, messageIDs interface{}) (*Update, error) {
	var ids []string
	switch v := messageIDs.(type) {
	case string:
		ids = []string{v}
	case []string:
		ids = v
	case []interface{}:
		for _, id := range v {
			ids = append(ids, fmt.Sprintf("%v", id))
		}
	}
	return c.Builder("getMessagesByID", false, true, map[string]interface{}{
		"object_guid": objectGUID,
		"message_ids": ids,
	})
}

func (c *RubClient) SetPinMessage(objectGUID, messageID, action string) (*Update, error) {
	return c.Builder("setPinMessage", false, true, map[string]interface{}{
		"object_guid": objectGUID,
		"message_id":  messageID,
		"action":      action,
	})
}

func (c *RubClient) GetGroupInfo(groupGUID string) (*Update, error) {
	return c.Builder("getGroupInfo", false, true, map[string]interface{}{
		"group_guid": groupGUID,
	})
}

func (c *RubClient) GetChannelInfo(channelGUID string) (*Update, error) {
	return c.Builder("getChannelInfo", false, true, map[string]interface{}{
		"channel_guid": channelGUID,
	})
}

func (c *RubClient) SendChatActivity(objectGUID, activity string) (*Update, error) {
	return c.Builder("sendChatActivity", false, true, map[string]interface{}{
		"object_guid": objectGUID,
		"activity":    activity,
	})
}

func (c *RubClient) ActionOnMessageReaction(objectGUID, messageID, action string, reactionID int) (*Update, error) {
	return c.Builder("actionOnMessageReaction", false, true, map[string]interface{}{
		"object_guid": objectGUID,
		"message_id":  messageID,
		"action":      action,
		"reaction_id": reactionID,
	})
}

func (c *RubClient) BanGroupMember(objectGUID, userGUID, action string) (*Update, error) {
	if action == "" {
		action = "Set"
	}
	return c.Builder("banGroupMember", false, true, map[string]interface{}{
		"group_guid":  objectGUID,
		"member_guid": userGUID,
		"action":      action,
	})
}

func (c *RubClient) BanChannelMember(objectGUID, userGUID, action string) (*Update, error) {
	if action == "" {
		action = "Set"
	}
	return c.Builder("banChannelMember", false, true, map[string]interface{}{
		"channel_guid": objectGUID,
		"member_guid":  userGUID,
		"action":       action,
	})
}

func (c *RubClient) GetGroupAdminMembers(groupGUID string) (*Update, error) {
	return c.Builder("getGroupAdminMembers", false, true, map[string]interface{}{
		"group_guid": groupGUID,
	})
}

func (c *RubClient) GetChannelAdminMembers(channelGUID string) (*Update, error) {
	return c.Builder("getChannelAdminMembers", false, true, map[string]interface{}{
		"channel_guid": channelGUID,
	})
}

func (c *RubClient) SeenChats(seenList map[string]string) (*Update, error) {
	var seenArr []map[string]string
	for guid, msgID := range seenList {
		seenArr = append(seenArr, map[string]string{
			"object_guid": guid,
			"message_id":  msgID,
		})
	}
	return c.Builder("seenChats", false, true, map[string]interface{}{
		"seen_list": seenArr,
	})
}

func (c *RubClient) SetBlockUser(userGUID string) (*Update, error) {
	return c.Builder("setBlockUser", false, true, map[string]interface{}{
		"user_guid": userGUID,
		"action":    "Block",
	})
}

func (c *RubClient) UnblockUser(userGUID string) (*Update, error) {
	return c.Builder("setBlockUser", false, true, map[string]interface{}{
		"user_guid": userGUID,
		"action":    "Unblock",
	})
}

func (c *RubClient) GetInfo(objectGUID string) (*Update, error) {
	if strings.HasPrefix(objectGUID, "g0") {
		return c.GetGroupInfo(objectGUID)
	} else if strings.HasPrefix(objectGUID, "c0") {
		return c.GetChannelInfo(objectGUID)
	}
	return c.GetUserInfo(objectGUID)
}

// ─── SendMessage (Complete Implementation) ──────────────────────────

type SendMessageOptions struct {
	ObjectGUID       string
	Text             string
	ReplyToMessageID string
	FileInline       interface{} // string (path/url), []byte, *Update, map[string]interface{}
	Sticker          interface{} // *Update or map[string]interface{}
	Type             string      // File, Image, Video, Music, Voice, Gif, VideoMessage
	IsSpoil          bool
	Thumb            bool // Enable thumbnail generation
	AudioInfo        bool // Enable audio info extraction
	AutoDelete       float64
	ParseMode        string
	Metadata         interface{}
	FileName         string
	Time             int
	Width            int
	Height           int
	Performer        string
}

func (c *RubClient) SendMessage(opts SendMessageOptions) (*Update, error) {
	if c.connection == nil {
		return nil, ErrNoConnection
	}

	objectGUID := opts.ObjectGUID
	lower := strings.ToLower(objectGUID)
	if lower == "me" || lower == "cloud" || lower == "self" {
		objectGUID = c.GUID
	}

	if opts.Type == "" {
		opts.Type = "File"
	}

	// Default thumb and audioInfo to true
	if opts.FileInline != nil {
		if !opts.Thumb {
			opts.Thumb = true
		}
		if !opts.AudioInfo {
			opts.AudioInfo = true
		}
	}

	rnd := mathrand.Intn(1000000) + 1

	inputData := map[string]interface{}{
		"object_guid": objectGUID,
		"rnd":         fmt.Sprintf("%d", rnd),
	}

	if opts.ReplyToMessageID != "" {
		inputData["reply_to_message_id"] = opts.ReplyToMessageID
	}

	// Process text and parse mode
	if opts.Text != "" {
		inputData["text"] = strings.TrimSpace(opts.Text)

		parseMode := opts.ParseMode
		if parseMode == "" {
			parseMode = c.ParseMode
		}

		if parseMode != "" {
			var mdResult MetadataResult
			if parseMode == "html" {
				// Convert HTML to markdown first
				mdText := c.markdown.ToMarkdown(opts.Text)
				mdResult = c.markdown.ToMetadata(mdText)
			} else {
				mdResult = c.markdown.ToMetadata(opts.Text)
			}
			inputData["text"] = mdResult.Text
			if mdResult.Metadata != nil {
				metaJSON, _ := json.Marshal(mdResult.Metadata)
				var metaMap map[string]interface{}
				json.Unmarshal(metaJSON, &metaMap)
				inputData["metadata"] = metaMap
			}
		}

		// Handle custom metadata
		if opts.Metadata != nil {
			switch m := opts.Metadata.(type) {
			case map[string]interface{}:
				if _, ok := m["metadata"]; ok {
					for k, v := range m {
						inputData[k] = v
					}
				} else {
					inputData["metadata"] = m
				}
			case *Update:
				for k, v := range m.Data {
					inputData[k] = v
				}
			}
		}
	}

	// Process sticker
	if opts.Sticker != nil {
		switch s := opts.Sticker.(type) {
		case *Update:
			inputData["sticker"] = s.Data
		case map[string]interface{}:
			inputData["sticker"] = s
		}
	}

	// Process file inline
	var fileInlineData map[string]interface{}
	var fileBytes []byte

	if opts.FileInline != nil {
		switch fi := opts.FileInline.(type) {
		case string:
			if strings.HasPrefix(fi, "http://") || strings.HasPrefix(fi, "https://") {
				// Download from URL
				resp, err := http.Get(fi)
				if err != nil {
					return nil, fmt.Errorf("failed to download file: %w", err)
				}
				data, err := io.ReadAll(resp.Body)
				resp.Body.Close()
				if err != nil {
					return nil, err
				}

				if opts.FileName == "" {
					contentType := resp.Header.Get("Content-Type")
					exts, _ := mime.ExtensionsByType(contentType)
					ext := ""
					if len(exts) > 0 {
						ext = exts[0]
					} else {
						ext = "." + strings.ToLower(opts.Type)
					}
					opts.FileName = fmt.Sprintf("%d%s", rnd, ext)
				}

				fileBytes = data
			} else {
				// Read from file path
				data, err := os.ReadFile(fi)
				if err != nil {
					return nil, fmt.Errorf("failed to read file: %w", err)
				}
				if opts.FileName == "" {
					opts.FileName = filepath.Base(fi)
				}
				fileBytes = data
			}

		case []byte:
			if opts.FileName == "" {
				opts.FileName = fmt.Sprintf("%d.%s", rnd, strings.ToLower(opts.Type))
			}
			fileBytes = fi

		case *Update:
			fileInlineData = fi.Data

		case map[string]interface{}:
			fileInlineData = fi
		}

		// Process bytes if we have them
		if fileBytes != nil {
			var thumb *ResultMedia
			var audioInfo *AudioResult

			// Handle Music/Voice - no thumbnail
			if opts.Type == "Music" || opts.Type == "Voice" {
				if opts.AudioInfo {
					audioInfo = c.audio.GetAudioInfo(fileBytes)
				}
			} else if opts.Thumb {
				// Generate thumbnail for video/image
				switch opts.Type {
				case "Video", "Gif", "VideoMessage":
					thumb = c.mediaThumbnail.FromVideo(fileBytes)
				case "Image":
					thumb = c.mediaThumbnail.FromImage(fileBytes)
				}
			}

			// If thumbnail generation failed, fall back to File type
			if opts.Thumb && thumb != nil && !thumb.HasImage() {
				if opts.Type != "Music" && opts.Type != "Voice" && opts.Type != "File" {
					opts.Type = "File"
					thumb = nil
				}
			}

			// Upload the file
			uploaded, err := c.Upload(fileBytes, opts.FileName, "")
			if err != nil {
				return nil, err
			}
			fileInlineData = uploaded.Data

			// Set file type
			fileType := opts.Type
			if fileType == "VideoMessage" {
				fileInlineData["is_round"] = true
				fileType = "Video"
			}
			fileInlineData["type"] = fileType

			// Set default values
			setDefault := func(key string, val interface{}) {
				if _, ok := fileInlineData[key]; !ok {
					fileInlineData[key] = val
				}
			}

			if opts.Time > 0 {
				fileInlineData["time"] = opts.Time
			} else {
				setDefault("time", 1)
			}
			if opts.Width > 0 {
				fileInlineData["width"] = opts.Width
			} else {
				setDefault("width", 200)
			}
			if opts.Height > 0 {
				fileInlineData["height"] = opts.Height
			} else {
				setDefault("height", 200)
			}
			if opts.Performer != "" {
				fileInlineData["music_performer"] = opts.Performer
			} else {
				setDefault("music_performer", "")
			}

			// Apply thumbnail data
			if thumb != nil && thumb.HasImage() {
				fileInlineData["time"] = thumb.Seconds
				fileInlineData["width"] = thumb.Width
				fileInlineData["height"] = thumb.Height
				fileInlineData["thumb_inline"] = thumb.ToBase64()
			}

			// Apply audio info
			if audioInfo != nil {
				if opts.Performer == "" {
					fileInlineData["music_performer"] = audioInfo.Performer
				}
				if opts.Time == 0 {
					if opts.Type == "Music" {
						fileInlineData["time"] = audioInfo.Duration
					} else {
						fileInlineData["time"] = audioInfo.Duration * 1000
					}
				}
			}

			fileInlineData["is_spoil"] = opts.IsSpoil
		}

		if fileInlineData != nil {
			inputData["file_inline"] = fileInlineData
		}
	}

	// Send message
	var result *Update
	var err error

	if fileInlineData != nil {
		result, err = c.Builder("sendMessage", false, true, inputData)
	} else {
		if text, ok := inputData["text"].(string); ok && text != "" {
			chunks := splitText(text, 4200)
			if len(chunks) == 0 {
				result, err = c.Builder("sendMessage", false, true, inputData)
			} else {
				for _, chunk := range chunks {
					inputData["text"] = strings.TrimSpace(chunk)
					inputData["rnd"] = fmt.Sprintf("%d", mathrand.Intn(1000000)+1)
					result, err = c.Builder("sendMessage", false, true, inputData)
					if err != nil {
						return nil, err
					}
				}
			}
		} else {
			result, err = c.Builder("sendMessage", false, true, inputData)
		}
	}

	if err != nil {
		return nil, err
	}

	// Auto delete
	if opts.AutoDelete > 0 && result != nil {
		go func() {
			time.Sleep(time.Duration(opts.AutoDelete * float64(time.Second)))
			msgID := result.GetString("message_id")
			if msgID != "" {
				c.DeleteMessages(objectGUID, []string{msgID})
			}
		}()
	}

	return result, nil
}

func (c *RubClient) Upload(data []byte, fileName, mimeType string) (*Update, error) {
	return c.connection.UploadFile(data, fileName, mimeType, DefaultChunkSize, nil)
}

func (c *RubClient) DownloadFile(fileInline *Update, saveAs string) ([]byte, error) {
	if fileInline == nil {
		return nil, errors.New("file_inline is nil")
	}

	dcID := fileInline.GetString("dc_id")
	fileID := fileInline.GetString("file_id")
	accessHash := fileInline.GetString("access_hash_rec")
	sizeVal := fileInline.Get("size")

	var size int64
	switch s := sizeVal.(type) {
	case float64:
		size = int64(s)
	case int64:
		size = s
	case int:
		size = int64(s)
	case string:
		size, _ = strconv.ParseInt(s, 10, 64)
	}

	return c.connection.Download(dcID, fileID, accessHash, size, DownloadChunk, nil, saveAs)
}

// ─── Start / Run / Disconnect ───────────────

func (c *RubClient) Start(phoneNumber string) error {
	if c.connection == nil {
		if err := c.Connect(); err != nil {
			return err
		}
	}

	if c.Auth != "" {
		c.DecodeAuthStr = c.cryptoHelper.DecodeAuth(c.Auth)
		c.Key = c.cryptoHelper.Passphrase(c.Auth)
	}

	if c.PrivateKey != "" {
		key, err := parsePrivateKey(c.PrivateKey)
		if err == nil {
			c.ImportKey = key
		}
	}

	result, err := c.GetMe()
	if err != nil {
		if isInvalidOrNotRegistered(err) {
			c.logger.Println("User not registered! Starting registration...")

			c.Auth = ""
			c.Key = ""
			c.DecodeAuthStr = ""
			c.ImportKey = nil

			if phoneNumber == "" {
				fmt.Print("Phone Number: ")
				fmt.Scanln(&phoneNumber)

				for {
					fmt.Printf("Is the %s correct? [y/n] > ", phoneNumber)
					var confirm string
					fmt.Scanln(&confirm)
					if strings.EqualFold(confirm, "y") {
						break
					}
					fmt.Print("Phone Number: ")
					fmt.Scanln(&phoneNumber)
				}
			}

			phoneNumber = normalizePhoneNumber(phoneNumber)
			if strings.HasPrefix(phoneNumber, "0") {
				phoneNumber = "98" + phoneNumber[1:]
			}

			c.Auth = c.cryptoHelper.Secret(32)
			c.Key = c.cryptoHelper.Passphrase(c.Auth)
			c.DecodeAuthStr = c.cryptoHelper.DecodeAuth(c.Auth)
			c.logger.Printf("Created tmp auth: %s", truncate(c.Auth, 8))

			sendResult, err := c.SendCode(phoneNumber, "", "SMS")
			if err != nil {
				return fmt.Errorf("send code error: %w", err)
			}

			if sendResult.GetString("status") == "SendPassKey" {
				for {
					hintPassKey := sendResult.GetString("hint_pass_key")
					fmt.Printf("Password [%s] > ", hintPassKey)
					var passKey string
					fmt.Scanln(&passKey)
					sendResult, err = c.SendCode(phoneNumber, passKey, "SMS")
					if err != nil {
						continue
					}
					if sendResult.GetString("status") == "OK" {
						break
					}
				}
			}

			publicKey, privateKey, err := c.cryptoHelper.CreateKeys()
			if err != nil {
				return fmt.Errorf("create keys error: %w", err)
			}
			c.PrivateKey = privateKey
			phoneCodeHash := sendResult.GetString("phone_code_hash")

			for {
				fmt.Print("Code: ")
				var phoneCode string
				fmt.Scanln(&phoneCode)

				signResult, err := c.SignIn(phoneCode, phoneNumber, phoneCodeHash, publicKey)
				if err != nil {
					c.logger.Printf("Sign in error: %v", err)
					continue
				}

				signStatus := signResult.GetString("status")
				if signStatus == "OK" {
					encAuth := signResult.GetString("auth")
					decAuth, err := c.cryptoHelper.DecryptRSAOAEP(c.PrivateKey, encAuth)
					if err != nil {
						return fmt.Errorf("decrypt auth error: %w", err)
					}

					c.Auth = decAuth
					c.Key = c.cryptoHelper.Passphrase(c.Auth)
					c.DecodeAuthStr = c.cryptoHelper.DecodeAuth(c.Auth)

					key, err := parsePrivateKey(c.PrivateKey)
					if err == nil {
						c.ImportKey = key
					}

					userUpdate := signResult.GetUpdate("user")
					userGUID := ""
					userPhone := ""
					if userUpdate != nil {
						userGUID = userUpdate.GetString("user_guid")
						userPhone = userUpdate.GetString("phone")
					}

					c.GUID = userGUID
					if err := c.session.Insert(
						c.Auth, userGUID, c.UserAgent, userPhone, c.PrivateKey,
					); err != nil {
						c.logger.Printf("Failed to save session: %v", err)
					}
					c.RegisterDevice(c.Name)
					c.logger.Printf("Registered successfully! GUID: %s", c.GUID)
					break
				}
			}
		} else {
			return fmt.Errorf("get user info error: %w", err)
		}
	} else {
		userUpdate := result.GetUpdate("user")
		if userUpdate != nil {
			c.GUID = userUpdate.GetString("user_guid")
		}
		c.logger.Printf("Logged in - User GUID: %s", c.GUID)
	}

	return nil
}

func (c *RubClient) Run() {
	if c.connection == nil {
		c.logger.Println("Not connected. Call Connect() and Start() first.")
		return
	}
	c.connection.GetUpdates(c.stopCh)
}

func (c *RubClient) RunInBackground() {
	go c.Run()
}

func (c *RubClient) AddHandler(name string, fn func(*Update), filter func(map[string]interface{}) bool) {
	c.handlersMu.Lock()
	defer c.handlersMu.Unlock()
	c.handlers = append(c.handlers, Handler{
		Name:   capitalizeStr(name),
		Func:   fn,
		Filter: filter,
	})
}

func (c *RubClient) OnMessage(fn func(*Update)) {
	c.AddHandler("chat_updates", fn, func(_ map[string]interface{}) bool {
		return true
	})
}

func (c *RubClient) OnMessageMatch(pattern string, fn func(*Update)) {
	re := regexp.MustCompile(pattern)
	c.AddHandler("chat_updates", fn, func(data map[string]interface{}) bool {
		if msg, ok := data["message"].(map[string]interface{}); ok {
			if text, ok := msg["text"].(string); ok {
				return re.MatchString(text)
			}
		}
		return false
	})
}

// Disconnect closes all connections
func (c *RubClient) Disconnect() error {
	if c.connection == nil {
		return ErrNoConnection
	}

	select {
	case <-c.stopCh:
		// Already closed
	default:
		close(c.stopCh)
	}

	err := c.connection.Close()
	if c.session != nil {
		c.session.Close()
	}
	c.logger.Println("Client disconnected.")
	return err
}

// GetSessionString returns the session as a string (for StringSession)
func (c *RubClient) GetSessionString() (string, error) {
	ss := &StringSession{
		Auth:       c.Auth,
		GUID:       c.GUID,
		UserAgent:  c.UserAgent,
		PrivateKey: c.PrivateKey,
	}
	return ss.Encode()
}

// ═══════════════════════════════════════════════════════════════════════════════
//  Helper Functions
// ═══════════════════════════════════════════════════════════════════════════════

func capitalizeStr(text string) string {
	parts := strings.Split(text, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]) + part[1:])
		}
	}
	return result.String()
}

func truncate(s string, n int) string {
	if len(s) <= n {
		return s
	}
	return s[:n] + "..."
}

func splitText(text string, chunkSize int) []string {
	runes := []rune(text)
	if len(runes) <= chunkSize {
		return []string{text}
	}
	var chunks []string
	for i := 0; i < len(runes); i += chunkSize {
		end := i + chunkSize
		if end > len(runes) {
			end = len(runes)
		}
		chunks = append(chunks, string(runes[i:end]))
	}
	return chunks
}

func normalizePhoneNumber(phone string) string {
	phone = convertFarsiDigits(phone)
	phone = strings.TrimSpace(phone)
	for _, ch := range []string{" ", "-", "(", ")"} {
		phone = strings.ReplaceAll(phone, ch, "")
	}
	re := regexp.MustCompile(`^(?:\+|00)?(\d{7,15})$`)
	match := re.FindStringSubmatch(phone)
	if len(match) >= 2 {
		return match[1]
	}
	return phone
}

func convertFarsiDigits(text string) string {
	farsi := []rune("۰۱۲۳۴۵۶۷۸۹")
	result := []rune(text)
	for i, r := range result {
		for j, f := range farsi {
			if r == f {
				result[i] = rune('0' + j)
				break
			}
		}
	}
	return string(result)
}

func encodeUTF16(s string) []uint16 {
	return utf16.Encode([]rune(s))
}

// getMimeFromURL gets mime type from URL
func getMimeFromURL(urlStr string) string {
	resp, err := http.Head(urlStr)
	if err != nil {
		return ""
	}
	defer resp.Body.Close()

	contentType := resp.Header.Get("Content-Type")
	if contentType == "" {
		return ""
	}

	exts, err := mime.ExtensionsByType(contentType)
	if err != nil || len(exts) == 0 {
		return ""
	}
	return exts[0]
}
